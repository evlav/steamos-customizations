#!/bin/bash
# -*- mode: sh; indent-tabs-mode: nil; sh-basic-offset: 4; -*-
# vim: et sts=4 sw=4

#  SPDX-License-Identifier: LGPL-2.1+
#
#  Copyright © 2019-2020 Collabora Ltd.
#  Copyright © 2019-2020 Valve Corporation.
#
#  This file is part of steamos-customizations.
#
#  steamos-customizations is free software; you can redistribute it and/or modify
#  it under the terms of the GNU Lesser General Public License as published
#  by the Free Software Foundation; either version 2.1 of the License, or
#  (at your option) any later version.

set -e
set -u

ERR=0 # the error code returned by this script

SYMLINKS_DIR=@udev_symlinks_absdir@
BOOTCONF_RELPATH=@bootconf_relpath@
PARTSETS_RELDIR=@partsets_reldir@
ROOTHASH_RELPATH=@roothash_relpath@
GRUB_VARCFG_RELPATH=@grub_var_config_relpath@

#
# Helpers
#

log () { echo >&2 "$@"; }
warn() { echo >&2 "Warning:" "$@"; }
err () { echo >&2 "Error:" "$@"; ERR=1; }
fail() { echo >&2 "Error:" "$@"; exit 1; }


#
# Re-enable systemd timers
#

RAUC_RUNTIME_DIR=/run/rauc
ACTIVE_TIMERS=$RAUC_RUNTIME_DIR/active-timers

if [ -e "$ACTIVE_TIMERS" ]; then
    while read -r service; do
        [[ "$service" ]] || continue
        systemctl start "$service"
    done < "$ACTIVE_TIMERS"
fi

rm -f $ACTIVE_TIMERS

#
# Handle the 'other' efi partition
#

configure_other_efi() {
    local efi=$1
    local roothash_update_file=$2
    local bootconf=
    local partsets=
    local roothash=
    local grub_varcfg=

    bootconf=$efi/$BOOTCONF_RELPATH
    if ! [ -e "$bootconf" ]; then
        log "Initializing 'other' efi bootconf: '$bootconf'"
        mkdir -p "$(dirname "$bootconf")"
        steamos-bootconf > "$bootconf"
    fi

    partsets=$efi/$PARTSETS_RELDIR
    if ! [ -e "$partsets" ]; then
        self_partsets="/efi/$PARTSETS_RELDIR"
        log "Initializing 'other' efi partsets: '$self_partsets' -> '$partsets'"
        mkdir -p "$partsets"
        cp "$self_partsets/all"    "$partsets/"
        cp "$self_partsets/other"  "$partsets/self"   # swapped!
        cp "$self_partsets/self"   "$partsets/other"  # swapped!
        cp "$self_partsets/shared" "$partsets/"
        if [ -e "$self_partsets/dev" ]; then
            cp "$self_partsets/dev" "$partsets/dev"
        fi
    fi

    roothash=$efi/$ROOTHASH_RELPATH
    mkdir -p "$(dirname "$roothash")"
    cp -f "$roothash_update_file" "$roothash"

    grub_varcfg=$efi/$GRUB_VARCFG_RELPATH
    if [ -e "$grub_varcfg" ]; then
        echo "Warning: $grub_varcfg is deprecated." >&2
    fi
    rm -f $grub_varcfg
}

log "Configuring the 'other' efi partition"

EFI_DEVICE_OTHER=$(realpath $SYMLINKS_DIR/other/efi)
[ -b "$EFI_DEVICE_OTHER" ] || fail "Other efi device '$EFI_DEVICE_OTHER' not found"

mount "$EFI_DEVICE_OTHER" /mnt
configure_other_efi /mnt "$RAUC_UPDATE_SOURCE/roothash" || \
    err "Failed to configure the 'other' efi"
umount /mnt

#
# Handle the 'other' var partition
#

ismounted() {
    local device=$1

    findmnt --real --source "$device" >/dev/null 2>&1
}

reformat_device_ext4() {
    local device=$1
    local opts=
    local label=

    device=$(readlink -f "$device")
    if ! [ -b "$device" ]; then
        warn "'$device' is not a block device"
        return
    fi

    if ismounted "$device"; then
        umount -v "$device"
    fi

    if ismounted "$device"; then
        umount -v -f "$device"
    fi

    label=$(e2label "$device")
    if [ "$label" ]; then
        opts="$opts -L $label"
    fi

    mkfs.ext4 -q -F $opts "$device"
}

sync_var_mountpoints() {
    local src=$1
    local dst=$2

    # --one-file-system makes sure that we ignore all the directories from /home
    # that are bind-mounted onto /var directories.
    #
    # We exclude the directories /var/lib/{dkms,modules,pacman}, as they don't
    # really represent a state that we want to keep, but rather a part of the
    # rootfs that ends up leaving in /var for technical reasons. These pieces
    # must be empty on first boot, so that they can be initialized from the
    # factory that is shipped with the rootfs.
    #
    # We also need to exclude /var/boot, which might contain the initrd that
    # was rebuilt to include nvidia drivers built by DKMS. Once again, this is
    # not a state that we want to keep.

    fsfreeze -f "$src"
    rsync \
        --archive \
        --delete \
        --one-file-system \
        --exclude="/boot/" \
        --exclude="/lib/dkms/" \
        --exclude="/lib/modules/" \
        --exclude="/lib/pacman/" \
        --exclude="/lost+found/" \
        "$src/" "$dst/" 
    fsfreeze -u "$src"
}

log "Syncing the var partitions from 'self' to 'other'"

VAR_DEVICE_OTHER=$(realpath $SYMLINKS_DIR/other/var)
[ -b "$VAR_DEVICE_OTHER" ] || fail "Other var device '$VAR_DEVICE_OTHER' not found"

reformat_device_ext4 "$VAR_DEVICE_OTHER" || \
    err "Failed to reformat other var partition"

mount "$VAR_DEVICE_OTHER" /mnt
sync_var_mountpoints /var /mnt || \
    err "Failed to sync var partitions"
umount /mnt

#
# Handle the bootloaders
# 

log "Installing the bootloaders"

ROOTHASH_FILE="$RAUC_UPDATE_SOURCE/roothash"
[ -e "$ROOTHASH_FILE" ] || fail "'$ROOTHASH_FILE' not found in the bundle"

ROOTHASH="$(cat "$ROOTHASH_FILE")"
[ "$ROOTHASH" ] || fail "'$ROOTHASH' is empty in the bundle"

steamos-chroot --partset other -- steamos-boot-install --no-kernel --roothash "$ROOTHASH" || \
    err "Failed to install bootloaders"

log "Reconfiguring the bootloader"

update-grub || \
    warn "Failed to reconfigure the bootloader"

#
# Notify that we should reboot to other
#

touch /run/steamos/reboot-other

exit $ERR
